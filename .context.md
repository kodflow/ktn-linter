# Context: Analyse VAR Rules 007-019 + Recommandations

Generated: 2026-01-01T17:45:00Z
Query: Analyse règles VAR-007 à VAR-019 pour rigueur académique et performance maximale
Iterations: 2

## Summary

Analyse complète des règles VAR basée sur les sources officielles Go (Effective Go, Code Review Comments, Go Spec, GC Guide). Certaines règles sont parfaitement alignées avec les best practices, d'autres nécessitent ajustements.

---

## Règles Existantes - Analyse Détaillée

### VAR-007: := vs var pour variables locales

**Status: ⚠️ MODIFIER - Trop strict**

**Sources:**
- [Effective Go](https://go.dev/doc/effective_go) - "Within a function, the short assignment statement `:=` may be used"
- [Go Tour](https://go.dev/tour/basics/10) - "Short variable declarations may appear only inside functions"

**Confidence:** HIGH

**Problème actuel:** La règle reporte `var err error = nil` mais `var err error` (zero value) est idiomatique.

**Modification requise:**
```go
// REPORTER (avec initialisation explicite redondante)
var x int = 42        // → utiliser x := 42
var err error = nil   // → utiliser var err error

// NE PAS REPORTER (zero value intentionnelle)
var err error         // OK - zero value explicite
var buf bytes.Buffer  // OK - zero value utilisable
```

---

### VAR-008: Slice preallocation

**Status: ✅ GARDER - Critique pour performance**

**Sources:**
- [Go Blog: Slices](https://go.dev/blog/slices) - "To increase the capacity of a slice one must create a new, larger slice and copy the contents"
- [prealloc benchmark](https://pkg.go.dev/github.com/golangci/prealloc) - ~4.5x faster, 5x fewer allocations

**Confidence:** HIGH

**Benchmark officiel:**
| Mode | ns/op | B/op | allocs/op |
|------|-------|------|-----------|
| Sans prealloc | 510 | 248 | 5 |
| Avec prealloc | 111 | 80 | 1 |

**Performance gain:** 4.5x

---

### VAR-009: make([]T, n) + append bug

**Status: ✅ GARDER - Bug pattern critique**

**Sources:**
- [Go Spec](https://go.dev/ref/spec) - "make(T, n) creates a slice with length n"
- [Go Blog: Slices Internals](https://go.dev/blog/slices-intro) - Explains length vs capacity

**Confidence:** HIGH

**Note:** Pattern bug fréquent. `make([]T, 10)` crée 10 éléments, `append` ajoute EN PLUS.

---

### VAR-010: Buffer.Grow()

**Status: ✅ GARDER - Performance**

**Sources:**
- [strings.Builder](https://pkg.go.dev/strings#Builder.Grow) - "Grow grows b's capacity, if necessary, to guarantee space"
- [bytes.Buffer](https://pkg.go.dev/bytes#Buffer.Grow) - Same pattern

**Confidence:** HIGH

---

### VAR-011: strings.Builder vs +

**Status: ✅ GARDER - Performance critique**

**Sources:**
- [strings.Builder docs](https://pkg.go.dev/strings#Builder) - "minimizes memory copying"

**Benchmark:**
| Method | ns/op | B/op | allocs/op |
|--------|-------|------|-----------|
| string + | 1113 | 6720 | 24 |
| Builder | 278 | 1448 | 6 |

**Performance gain:** 4x

**Confidence:** HIGH

---

### VAR-012: Allocations dans boucles

**Status: ✅ GARDER - Performance**

**Sources:**
- [GC Guide](https://go.dev/doc/gc-guide) - "allocating memory... is said to escape to the heap"
- [Performance Wiki](https://go.dev/wiki/Performance) - "reduce allocations"

**Confidence:** HIGH

---

### VAR-013: Struct size threshold

**Status: ⚠️ MODIFIER - Seuil à 64 bytes**

**Sources:**
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "Use pointers if receiver is large struct/array"
- [Effective Go](https://go.dev/doc/effective_go) - "If a struct is large, passing a pointer is more efficient"
- [GC Guide](https://go.dev/doc/gc-guide) - Escape analysis details

**Confidence:** MEDIUM (pas de seuil officiel précis)

**Recommandation basée sur l'architecture CPU:**
```
Seuil optimal: 64 bytes

Justification académique:
1. L1 cache line = 64 bytes sur x86-64 et ARM64
2. Copie ≤64 bytes = 1 seul fetch mémoire
3. Copie >64 bytes = cache line split possible
4. Pointeur (8 bytes) + indirection overhead

Trade-off:
- Copie: Pas de GC, localité cache, pas d'indirection
- Pointeur: GC scan, possible cache miss, indirection

Règle: >64 bytes ET modifié → pointeur
       ≤64 bytes OU read-only → valeur OK
```

---

### VAR-014: sync.Pool

**Status: ⚠️ GARDER AVEC RESTRICTIONS**

**Sources:**
- [sync.Pool docs](https://pkg.go.dev/sync#Pool) - "Pool's purpose is to cache allocated but unused items"
- [sync.Pool source](https://go.dev/src/sync/pool.go) - "amortize allocation overhead"

**Confidence:** MEDIUM

**Warning officiel:**
> "A free list maintained as part of a short-lived object is not a suitable use for a Pool"

**Quand suggérer Pool:**
- ✅ Buffers réutilisés entre goroutines (HTTP handlers)
- ✅ Objets coûteux à créer, utilisés fréquemment
- ❌ Objets short-lived dans une seule goroutine
- ❌ Petits objets (overhead > gain)

---

### VAR-015: string() répétition

**Status: ✅ GARDER - Performance**

**Sources:**
- [strings package](https://pkg.go.dev/strings) - Chaque conversion alloue une nouvelle string

**Confidence:** HIGH

---

### VAR-016: Groupement var()

**Status: ✅ GARDER - Style cohérent**

**Sources:**
- [Go Doc Comments](https://go.dev/doc/comment) - "grouped variables with shared doc comment"
- [Effective Go](https://go.dev/doc/effective_go) - Shows grouping pattern for related vars

**Confidence:** MEDIUM (style, améliore lisibilité)

---

### VAR-017: Map preallocation

**Status: ✅ GARDER - Performance critique avec Go 1.24**

**Sources:**
- [Go Spec](https://go.dev/ref/spec) - "make takes the map type and an optional capacity hint"
- [Swiss Tables Blog](https://go.dev/blog/swisstable) - "up to 60% faster" avec Go 1.24

**Confidence:** HIGH

**Note:** Encore plus important avec Swiss Tables (Go 1.24+)

---

### VAR-018: Array vs slice (stack allocation)

**Status: ⚠️ MODIFIER - Conditions plus précises**

**Sources:**
- [Escape Analysis Tests](https://go.dev/test/escape_array.go) - "small array literals are stack allocated"
- [GC Guide](https://go.dev/doc/gc-guide) - "size dynamically determined... escape to heap"

**Confidence:** HIGH

**Comportement réel du compilateur:**
```go
// TOUJOURS Stack (constant size small)
var buf [32]byte                    // Stack ✓
buf := make([]byte, 32)             // Stack ✓ (constant, petit)

// HEAP (dynamic ou grand)
n := 32
buf := make([]byte, n)              // Heap (variable size)
buf := make([]byte, 65537)          // Heap (>MaxStackVarSize)

// MaxStackVarSize ≈ 65536 bytes
```

**Modification:** Ne reporter que si:
- Taille constante ET petite (≤64 bytes)
- Pattern `make([]T, N)` où N est constant

---

### VAR-019: Mutex copies

**Status: ✅ GARDER - Critique sécurité**

**Sources:**
- [sync.Mutex docs](https://pkg.go.dev/sync#Mutex) - "A Mutex must not be copied after first use"
- [copylock analyzer](https://go.dev/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/copylock) - "may cause both copies to malfunction"

**Confidence:** HIGH

---

## Modification VAR-004 (longueur min)

**Basé sur [Code Review Comments](https://go.dev/wiki/CodeReviewComments):**

> "Variable names in Go should be short... Prefer `c` to `lineCount`. Prefer `i` to `sliceIndex`."

**Nouvelle logique:**

| Scope | Longueur min | Exceptions |
|-------|--------------|------------|
| Package-level | 2 chars | `_` |
| Function-level | 1 char OK | Si idiomatique |

**Noms 1-char idiomatiques autorisés en local:**
```go
// Loop counters
i, j, k, n

// Type hints
b  // byte/buffer
c  // channel/char
f  // file/float
m  // map
r  // reader
s  // string/slice
t  // time/type
w  // writer

// Results
ok  // boolean
```

---

## Nouvelles Règles Recommandées

### VAR-020: Nil slice préférée (HAUTE PRIORITÉ)

**Sources:**
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "Prefer nil slices over empty slices"

```go
// INCORRECT
t := []string{}           // want "KTN-VAR-020"
items := make([]int, 0)   // want "KTN-VAR-020"

// CORRECT
var t []string
var items []int
```

**Exception JSON:** Quand `nil` → `null` n'est pas souhaité

**Impact performance:** Aucun (même comportement runtime)
**Impact style:** Cohérence avec Go idiomatique

---

### VAR-021: Receiver type consistency (HAUTE PRIORITÉ)

**Sources:**
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "Don't mix receiver types"

```go
// INCORRECT - mixing receivers
type Server struct{}
func (s *Server) Start() {}
func (s Server) Stop() {}    // want "KTN-VAR-021"

// CORRECT
func (s *Server) Start() {}
func (s *Server) Stop() {}
```

**Raison:** Incohérence confuse, peut cacher des bugs (copie vs pointeur)

---

### VAR-022: Pointer to interface (MOYENNE PRIORITÉ)

**Sources:**
- [Effective Go](https://go.dev/doc/effective_go) - Interfaces already contain pointer
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "Don't pass pointers as function arguments just to save a few bytes"

```go
// INCORRECT
func Process(r *io.Reader) {}     // want "KTN-VAR-022"
func Handle(w *http.ResponseWriter) {}

// CORRECT
func Process(r io.Reader) {}
func Handle(w http.ResponseWriter) {}
```

**Exception:** `*error` peut être valide (pour modifier l'erreur)

---

### VAR-023: Crypto rand pour secrets (HAUTE PRIORITÉ - SÉCURITÉ)

**Sources:**
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "Do not use package math/rand to generate keys"

```go
// DANGEREUX - prédictible!
import "math/rand"
key := rand.Intn(1000000)         // want "KTN-VAR-023"

// CORRECT
import "crypto/rand"
key := rand.Text()
```

**Catégorie:** Sécurité (pas juste style)

---

### VAR-024: Goroutine lifetime clarity (OPTIONNEL)

**Sources:**
- [Code Review Comments](https://go.dev/wiki/CodeReviewComments) - "document when goroutines exit"

```go
// SUSPICIOUS - lifetime unclear
go process(data)                  // Quand termine?

// BETTER
go func() {
    defer wg.Done()
    process(data)
}()
```

**Note:** Difficile à implémenter statiquement, peut-être WARNING seulement

---

## Récapitulatif Actions

| Règle | Action | Priorité | Effort |
|-------|--------|----------|--------|
| VAR-004 | MODIFIER (scope-aware) | HIGH | Medium |
| VAR-007 | MODIFIER (zero value OK) | MEDIUM | Low |
| VAR-013 | MODIFIER (seuil 64 bytes) | MEDIUM | Low |
| VAR-014 | CLARIFIER (restrictions) | LOW | Low |
| VAR-018 | MODIFIER (conditions précises) | MEDIUM | Medium |
| VAR-020 | **AJOUTER** (nil slice) | HIGH | Low |
| VAR-021 | **AJOUTER** (receiver consistency) | HIGH | Medium |
| VAR-022 | **AJOUTER** (pointer to interface) | MEDIUM | Low |
| VAR-023 | **AJOUTER** (crypto rand) | HIGH | Low |

---

## Sources Summary

| Source | Domain | Confidence | Sections |
|--------|--------|------------|----------|
| [Effective Go](https://go.dev/doc/effective_go) | go.dev | HIGH | All |
| [Code Review Comments](https://go.dev/wiki/CodeReviewComments) | go.dev | HIGH | Naming, Style, Performance |
| [Go Spec](https://go.dev/ref/spec) | go.dev | HIGH | Syntax, Semantics |
| [GC Guide](https://go.dev/doc/gc-guide) | go.dev | HIGH | Performance, Allocation |
| [Slices Blog](https://go.dev/blog/slices) | go.dev | HIGH | Performance |
| [Swiss Tables Blog](https://go.dev/blog/swisstable) | go.dev | HIGH | Map Performance |
| [sync package](https://pkg.go.dev/sync) | pkg.go.dev | HIGH | Concurrency |
| [Escape Analysis](https://go.dev/test/escape_array.go) | go.dev | HIGH | Stack vs Heap |

---

_Ce fichier est généré automatiquement par `/search`. Ne pas commiter._
