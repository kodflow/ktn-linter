#!/bin/bash
# Wrapper for golangci-lint + KTN-Linter integration
# Transparently runs both linters and combines results

LINTER_BIN="/workspace/builds/ktn-linter"
CONFIG_FILE="/workspace/.golangci.yml"

# Ensure ktn-linter is installed
if [ ! -f "$LINTER_BIN" ]; then
    # Build from source
    cd /workspace
    go build -buildvcs=false -o "$LINTER_BIN" ./cmd/ktn-linter 2>&1 >/dev/null
fi

cd /workspace

# Real golangci-lint binary path
REAL_GOLANGCI_LINT="/usr/local/bin/golangci-lint"

# Temporary file for combined output
TEMP_OUTPUT=$(mktemp)

# Check if golangci-lint has any linters enabled
# Skip if config has "default: none" and "enable: []"
RUN_GOLANGCI=false
if [ -x "$REAL_GOLANGCI_LINT" ] && [ -f "$CONFIG_FILE" ]; then
    # Check if any linters are enabled (not "enable: []")
    if grep -q "enable: \[" "$CONFIG_FILE" && ! grep -q "enable: \[\]" "$CONFIG_FILE"; then
        RUN_GOLANGCI=true
    fi
fi

# Run real golangci-lint only if linters are enabled
if [ "$RUN_GOLANGCI" = true ] && [[ "$*" != *"testdata"* ]]; then
    "$REAL_GOLANGCI_LINT" "$@" 2>&1 >> "$TEMP_OUTPUT" || true
fi

# Filtrer les arguments golangci-lint pour garder uniquement les packages/chemins
TARGETS=()
for arg in "$@"; do
    # Ignorer les flags golangci-lint et la commande "run"
    if [[ ! "$arg" =~ ^- ]] && [[ "$arg" != "run" ]]; then
        TARGETS+=("$arg")
    fi
done

# Run KTN-Linter (skip testdata - use 'make validate' for testdata validation)
if [ ${#TARGETS[@]} -eq 0 ]; then
    # Scanner le projet principal (testdata exclu automatiquement par go list ./...)
    "$LINTER_BIN" lint ./... 2>&1 >> "$TEMP_OUTPUT" || true
else
    # Exécuter le linter sur les cibles spécifiées
    "$LINTER_BIN" lint "${TARGETS[@]}" 2>&1 >> "$TEMP_OUTPUT" || true
fi

# Output combined results
cat "$TEMP_OUTPUT"
rm -f "$TEMP_OUTPUT"

exit 0
