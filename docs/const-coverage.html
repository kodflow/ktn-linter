
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>const: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/001.go (93.3%)</option>
				
				<option value="file1">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/002.go (92.1%)</option>
				
				<option value="file2">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/003.go (87.5%)</option>
				
				<option value="file3">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/004.go (89.3%)</option>
				
				<option value="file4">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/005.go (88.9%)</option>
				
				<option value="file5">github.com/kodflow/ktn-linter/src/pkg/analyzer/ktn/const/registry.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ktnconst

import (
        "go/ast"
        "go/token"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Analyzer001 checks that constants have explicit types
var Analyzer001 = &amp;analysis.Analyzer{
        Name:     "ktnconst001",
        Doc:      "KTN-CONST-001: Vérifie que les constantes ont un type explicite",
        Run:      runConst001,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func runConst001(pass *analysis.Pass) (any, error) <span class="cov8" title="1">{
        inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        nodeFilter := []ast.Node{
                (*ast.GenDecl)(nil),
        }

        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                genDecl := n.(*ast.GenDecl)

                // Only check const declarations
                if genDecl.Tok != token.CONST </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        valueSpec, ok := spec.(*ast.ValueSpec)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if the constant has an explicit type
                        <span class="cov8" title="1">if valueSpec.Type == nil </span><span class="cov8" title="1">{
                                // If there are values, it's an error (not inheriting from iota pattern)
                                // If there are no values, it's OK (inheriting type and value from previous line - iota pattern)
                                if len(valueSpec.Values) &gt; 0 </span><span class="cov8" title="1">{
                                        for _, name := range valueSpec.Names </span><span class="cov8" title="1">{
                                                pass.Reportf(
                                                        name.Pos(),
                                                        "KTN-CONST-001: la constante '%s' doit avoir un type explicite",
                                                        name.Name,
                                                )
                                        }</span>
                                }
                        }
                }
        })

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ktnconst

import (
        "go/ast"
        "go/token"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Analyzer002 checks that constants are grouped together and placed above var declarations
var Analyzer002 = &amp;analysis.Analyzer{
        Name:     "ktnconst002",
        Doc:      "KTN-CONST-002: Vérifie que les constantes sont groupées ensemble et placées au-dessus des déclarations var",
        Run:      runConst002,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func runConst002(pass *analysis.Pass) (any, error) <span class="cov8" title="1">{
        inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        // For each file, track the positions of const and var declarations
        fileDecls := make(map[*ast.File]*declTracker)

        nodeFilter := []ast.Node{
                (*ast.File)(nil),
        }

        // First pass: collect all files
        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                file := n.(*ast.File)
                fileDecls[file] = &amp;declTracker{
                        constGroups: []declGroup{},
                        varGroups:   []declGroup{},
                }
        }</span>)

        // Second pass: analyze declarations in each file
        <span class="cov8" title="1">for _, file := range pass.Files </span><span class="cov8" title="1">{
                tracker := fileDecls[file]
                if tracker == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Collect const and var declarations
                <span class="cov8" title="1">for _, decl := range file.Decls </span><span class="cov8" title="1">{
                        genDecl, ok := decl.(*ast.GenDecl)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">switch genDecl.Tok </span>{
                        case token.CONST:<span class="cov8" title="1">
                                tracker.constGroups = append(tracker.constGroups, declGroup{
                                        decl: genDecl,
                                        pos:  genDecl.Pos(),
                                })</span>
                        case token.VAR:<span class="cov8" title="1">
                                tracker.varGroups = append(tracker.varGroups, declGroup{
                                        decl: genDecl,
                                        pos:  genDecl.Pos(),
                                })</span>
                        }
                }

                // Check violations
                <span class="cov8" title="1">checkConstGrouping(pass, tracker)</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

type declTracker struct {
        constGroups []declGroup
        varGroups   []declGroup
}

type declGroup struct {
        decl *ast.GenDecl
        pos  token.Pos
}

func checkConstGrouping(pass *analysis.Pass, tracker *declTracker) <span class="cov8" title="1">{
        // If no const declarations, nothing to check
        if len(tracker.constGroups) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // If no var declarations, only check if consts are scattered
        <span class="cov8" title="1">if len(tracker.varGroups) == 0 </span><span class="cov8" title="1">{
                checkScatteredConsts(pass, tracker.constGroups)
                return
        }</span>

        // Find the position of the first var declaration
        <span class="cov8" title="1">firstVarPos := tracker.varGroups[0].pos

        // Separate consts into those before and after first var
        constGroupsBeforeVar := []declGroup{}
        constGroupsAfterVar := []declGroup{}

        for _, constGroup := range tracker.constGroups </span><span class="cov8" title="1">{
                if constGroup.pos &lt; firstVarPos </span><span class="cov8" title="1">{
                        constGroupsBeforeVar = append(constGroupsBeforeVar, constGroup)
                }</span> else<span class="cov8" title="1"> {
                        constGroupsAfterVar = append(constGroupsAfterVar, constGroup)
                }</span>
        }

        // Report consts that appear after var
        <span class="cov8" title="1">for _, constGroup := range constGroupsAfterVar </span><span class="cov8" title="1">{
                pass.Reportf(
                        constGroup.pos,
                        "KTN-CONST-002: les constantes doivent être groupées et placées au-dessus des déclarations var",
                )
        }</span>

        // Check if consts before vars are scattered
        <span class="cov8" title="1">checkScatteredConsts(pass, constGroupsBeforeVar)</span>
}

func checkScatteredConsts(pass *analysis.Pass, constGroups []declGroup) <span class="cov8" title="1">{
        // If 0 or 1 const group, they're not scattered
        if len(constGroups) &lt;= 1 </span><span class="cov8" title="1">{
                return
        }</span>

        // Report all const groups except the first as scattered
        <span class="cov8" title="1">for i := 1; i &lt; len(constGroups); i++ </span><span class="cov8" title="1">{
                pass.Reportf(
                        constGroups[i].pos,
                        "KTN-CONST-002: les constantes doivent être groupées ensemble dans un seul bloc",
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ktnconst

import (
        "go/ast"
        "go/token"
        "regexp"
        "strings"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Analyzer003 checks that constants use CAPITAL_UNDERSCORE naming convention
var Analyzer003 = &amp;analysis.Analyzer{
        Name:     "ktnconst003",
        Doc:      "KTN-CONST-003: Vérifie que les constantes utilisent la convention CAPITAL_UNDERSCORE",
        Run:      runConst003,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

// validConstNamePattern matches valid CAPITAL_UNDERSCORE constant names
// Must start with uppercase letter, followed by uppercase letters, digits, or underscores
// Must contain at least one underscore for multi-word constants
var validConstNamePattern = regexp.MustCompile(`^[A-Z][A-Z0-9_]*$`)

func runConst003(pass *analysis.Pass) (any, error) <span class="cov8" title="1">{
        inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        nodeFilter := []ast.Node{
                (*ast.GenDecl)(nil),
        }

        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                genDecl := n.(*ast.GenDecl)

                // Only check const declarations
                if genDecl.Tok != token.CONST </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        valueSpec, ok := spec.(*ast.ValueSpec)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, name := range valueSpec.Names </span><span class="cov8" title="1">{
                                constName := name.Name

                                // Skip blank identifiers
                                if constName == "_" </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                // Check if the constant name follows CAPITAL_UNDERSCORE convention
                                <span class="cov8" title="1">if !isValidConstantName(constName) </span><span class="cov8" title="1">{
                                        pass.Reportf(
                                                name.Pos(),
                                                "KTN-CONST-003: la constante '%s' doit utiliser la convention CAPITAL_UNDERSCORE (ex: MAX_SIZE, API_KEY, HTTP_TIMEOUT)",
                                                constName,
                                        )
                                }</span>
                        }
                }
        })

        <span class="cov8" title="1">return nil, nil</span>
}

// isValidConstantName checks if a constant name follows CAPITAL_UNDERSCORE convention
func isValidConstantName(name string) bool <span class="cov8" title="1">{
        // Must match the pattern: starts with uppercase, contains only uppercase, digits, underscores
        if !validConstNamePattern.MatchString(name) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Single letter constants are valid (e.g., A, B, C)
        <span class="cov8" title="1">if len(name) == 1 </span><span class="cov8" title="1">{
                return true
        }</span>

        // For multi-character names, check additional rules
        // Must not be all uppercase without underscores if it appears to be multi-word
        // This catches cases like MAXSIZE which should be MAX_SIZE

        // If the name has lowercase letters, it's invalid (already caught by regex, but for clarity)
        <span class="cov8" title="1">if strings.ToUpper(name) != name </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's a single word or properly uses underscores
        // Single uppercase acronyms are OK (e.g., API, HTTP, URL)
        // But if it looks like multiple words concatenated, it needs underscores

        // Simple heuristic: if it's longer than 4 characters and has no underscores,
        // it might be multiple words concatenated
        // However, we allow acronyms like HTTPS, MAXINT, etc.
        // The key rule is: it must be ALL CAPS and can use underscores

        // Since the requirement is to enforce CAPITAL_UNDERSCORE, we accept:
        // 1. Single letters: A, B, C
        // 2. Acronyms: API, HTTP, URL, HTTPS, EOF
        // 3. Underscored names: MAX_SIZE, API_KEY, HTTP_TIMEOUT
        // 4. Numbers are allowed: HTTP2, TLS1_2

        // The pattern already validates this, so just return true
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ktnconst

import (
        "go/ast"
        "go/token"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Analyzer004 checks that every constant has an associated comment
var Analyzer004 = &amp;analysis.Analyzer{
        Name:     "ktnconst004",
        Doc:      "KTN-CONST-004: Vérifie que chaque constante a un commentaire associé",
        Run:      runConst004,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func runConst004(pass *analysis.Pass) (any, error) <span class="cov8" title="1">{
        inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        nodeFilter := []ast.Node{
                (*ast.GenDecl)(nil),
        }

        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                genDecl := n.(*ast.GenDecl)

                // Only check const declarations
                if genDecl.Tok != token.CONST </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check if the GenDecl has a doc comment (applies to all constants in the group)
                // Filter out "want" directives used by analysistest
                <span class="cov8" title="1">hasGenDeclDoc := hasValidComment(genDecl.Doc)

                for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        valueSpec, ok := spec.(*ast.ValueSpec)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if this specific ValueSpec has a doc comment or line comment
                        // Filter out "want" directives used by analysistest
                        <span class="cov8" title="1">hasValueSpecDoc := hasValidComment(valueSpec.Doc)
                        hasValueSpecComment := hasValidComment(valueSpec.Comment)

                        // A constant is considered documented if:
                        // 1. The GenDecl has a doc comment (group documentation), OR
                        // 2. The ValueSpec has a doc comment (above the constant), OR
                        // 3. The ValueSpec has a line comment (on the same line)
                        hasComment := hasGenDeclDoc || hasValueSpecDoc || hasValueSpecComment

                        if !hasComment </span><span class="cov8" title="1">{
                                for _, name := range valueSpec.Names </span><span class="cov8" title="1">{
                                        pass.Reportf(
                                                name.Pos(),
                                                "KTN-CONST-004: la constante '%s' doit avoir un commentaire associé",
                                                name.Name,
                                        )
                                }</span>
                        }
                }
        })

        <span class="cov8" title="1">return nil, nil</span>
}

// hasValidComment checks if a comment group exists and contains valid comments
// (not just test directives like "want")
func hasValidComment(cg *ast.CommentGroup) bool <span class="cov8" title="1">{
        if cg == nil || len(cg.List) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if any comment is NOT a "want" directive
        <span class="cov8" title="1">for _, comment := range cg.List </span><span class="cov8" title="1">{
                text := comment.Text
                // Skip "want" directives used by analysistest
                // Line comment: // want "..."
                if len(text) &gt;= 6 &amp;&amp; text[2:6] == "want" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Block comment: /* want "..." */
                <span class="cov8" title="1">if len(text) &gt;= 7 &amp;&amp; text[2:7] == " want" </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Found a valid comment
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ktnconst

import (
        "go/ast"
        "go/token"
        "unicode"

        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/ast/inspector"
)

// Analyzer005 checks that all constants are exported (start with uppercase letter)
var Analyzer005 = &amp;analysis.Analyzer{
        Name:     "ktnconst005",
        Doc:      "KTN-CONST-005: Vérifie que toutes les constantes sont exportées (commencent par une majuscule)",
        Run:      runConst005,
        Requires: []*analysis.Analyzer{inspect.Analyzer},
}

func runConst005(pass *analysis.Pass) (any, error) <span class="cov8" title="1">{
        inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

        nodeFilter := []ast.Node{
                (*ast.GenDecl)(nil),
        }

        inspect.Preorder(nodeFilter, func(n ast.Node) </span><span class="cov8" title="1">{
                genDecl := n.(*ast.GenDecl)

                // Only check const declarations
                if genDecl.Tok != token.CONST </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">for _, spec := range genDecl.Specs </span><span class="cov8" title="1">{
                        valueSpec, ok := spec.(*ast.ValueSpec)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check each constant name
                        <span class="cov8" title="1">for _, name := range valueSpec.Names </span><span class="cov8" title="1">{
                                // Skip blank identifiers
                                if name.Name == "_" </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                // Check if the first character is uppercase
                                <span class="cov8" title="1">if len(name.Name) &gt; 0 </span><span class="cov8" title="1">{
                                        firstChar := rune(name.Name[0])
                                        if !unicode.IsUpper(firstChar) </span><span class="cov8" title="1">{
                                                pass.Reportf(
                                                        name.Pos(),
                                                        "KTN-CONST-005: la constante '%s' doit être exportée (commencer par une majuscule)",
                                                        name.Name,
                                                )
                                        }</span>
                                }
                        }
                }
        })

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ktnconst

import "golang.org/x/tools/go/analysis"

// Analyzers returns all const-related analyzers
func Analyzers() []*analysis.Analyzer <span class="cov0" title="0">{
        return []*analysis.Analyzer{
                Analyzer001,
                Analyzer002,
                Analyzer003,
                Analyzer004,
                Analyzer005,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
