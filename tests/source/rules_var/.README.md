# R√®gle : Variables Package-Level

## üìã Description

Les variables package-level en Go doivent √™tre **regroup√©es** dans des blocs `var ()`, **document√©es** avec un commentaire de groupe ET un commentaire individuel pour chaque variable, et **typ√©es explicitement**.

## üéØ Objectif

**Pourquoi cette r√®gle existe :**
- **Lisibilit√©** : Un code uniforme facilite la compr√©hension rapide
- **Maintenabilit√©** : Les commentaires expliquent le r√¥le de chaque variable
- **Coh√©sion** : Le regroupement th√©matique organise logiquement le code
- **Clart√© des types** : Les types explicites √©vitent les ambigu√Øt√©s
- **Diff√©renciation const/var** : Rend √©vident ce qui est mutable vs immuable
- **Documentation automatique** : Les outils de documentation (godoc) utilisent ces commentaires
- **S√©curit√©** : Variables mutables explicites r√©duisent les bugs de concurrence

## ‚úÖ Bonne Pratique (package-level.go)

```go
// Boolean variables
// Ces variables repr√©sentent des valeurs bool√©ennes pour la configuration
var (
	// EnableFeatureX active la fonctionnalit√© X
	EnableFeatureX bool = true
	// EnableDebug active le mode debug
	EnableDebug bool = false
	// isProduction indique si l'environnement est en production
	isProduction bool = true
)

// Channel variables
// Ces variables sont des channels pour la communication inter-goroutines
var (
	// MessageQueue est le channel pour les messages (buffer=100)
	MessageQueue chan string = make(chan string, 100)
	// ErrorQueue est le channel pour les erreurs (buffer=50)
	ErrorQueue chan error = make(chan error, 50)
	// doneSignal signale la fin d'ex√©cution (unbuffered intentionnel)
	doneSignal chan bool = make(chan bool)
)

// Counter variables
// Ces variables comptent les √©v√©nements (zero value intentionnelle)
var (
	// RequestCount compte le nombre total de requ√™tes
	RequestCount int = 0
	// ErrorCount compte le nombre total d'erreurs
	ErrorCount int = 0
)
```

### Pourquoi c'est bon :
- ‚úÖ **Regroupement th√©matique** : Les variables li√©es sont ensemble dans un bloc `var ()`
- ‚úÖ **Commentaire de groupe** : Explique le contexte global du groupe
- ‚úÖ **Commentaire individuel** : Chaque variable (publique ET priv√©e) a son propre commentaire
- ‚úÖ **Type explicite** : `bool`, `chan string`, `int`, etc. sont toujours sp√©cifi√©s
- ‚úÖ **Initialisation claire** : Channel buffer size, zero values intentionnelles
- ‚úÖ **Navigation facile** : Structure claire pour les d√©veloppeurs et les outils

## ‚ùå Mauvaise Pratique (package-level.go - source)

```go
// ‚ùå ERREUR 1: Variables non group√©es
var EnableFeatureX bool = true
var EnableDebug bool = false
var isProduction bool = true

// ‚ùå ERREUR 2: Pas de commentaire de groupe ET pas de commentaires individuels
var (
	ApplicationName string = "MyApp"
	Version         string = "1.0.0"
	defaultEncoding string = "UTF-8"
)

// ‚ùå ERREUR 3: Type non explicite (inf√©r√©)
var (
	MaxConnections = 1000  // Type manquant !
	DefaultPort = 8080     // Type manquant !
)

// ‚ùå ERREUR 9: Variables mutables (slice) sans type explicite complet
var (
	DefaultTags = []string{"production", "main"}  // Type inf√©r√© !
)

// ‚ùå ERREUR 13: Multiple variables sur une ligne
var (
	HostName, Port = "localhost", 8080  // Difficile √† documenter individuellement !
)

// ‚ùå ERREUR 14: Variable qui devrait √™tre une constante
var (
	Pi float64 = 3.14159265358979323846  // Valeur immuable ‚Üí devrait √™tre const !
)

// ‚ùå ERREUR 17: Channel sans buffer size explicite
var (
	MessageQueue chan string = make(chan string)  // Buffered ou unbuffered ?
)
```

### Pourquoi c'est mauvais :
- ‚ùå **Variables isol√©es** : Difficile de voir les relations entre variables
- ‚ùå **Manque de documentation** : Impossible de comprendre le r√¥le sans lire le code
- ‚ùå **Type implicite** : Ambigu√Øt√© sur le type r√©el
- ‚ùå **Confusion const/var** : Variables immuables qui devraient √™tre const
- ‚ùå **Channel flou** : Buffer size non clair (performance/s√©mantique)
- ‚ùå **Multiple assignment** : Commentaires individuels impossibles

## üîç D√©tection du Linter

### Codes d'erreur

| Code | Description |
|------|-------------|
| `KTN-VAR-001` | Variable d√©clar√©e sans regroupement `var ()` |
| `KTN-VAR-002` | Groupe de variables sans commentaire de groupe |
| `KTN-VAR-003` | Variable sans commentaire individuel |
| `KTN-VAR-004` | Variable sans type explicite |
| `KTN-VAR-005` | Variable devrait √™tre une constante (valeur immuable) |
| `KTN-VAR-006` | Multiple variables sur une ligne (utiliser plusieurs lignes) |
| `KTN-VAR-007` | Channel sans buffer size explicite dans le commentaire |
| `KTN-VAR-008` | Nom de variable avec underscore (utiliser MixedCaps) |
| `KTN-VAR-009` | Nom de variable en ALL_CAPS (utiliser MixedCaps) |

### Messages d'erreur

**KTN-VAR-001** :
```
Variable '{nom}' d√©clar√©e individuellement. Regroupez les variables dans un bloc var ().
Exemple:
  var (
      {nom} {type} = {valeur}
  )
```

**KTN-VAR-002** :
```
Groupe de variables sans commentaire de groupe.
Ajoutez un commentaire avant le bloc var () pour d√©crire l'ensemble.
Exemple:
  // Description du groupe de variables
  var (...)
```

**KTN-VAR-003** :
```
Variable '{nom}' sans commentaire individuel.
Chaque variable doit avoir un commentaire explicatif.
Exemple:
  // {nom} d√©crit son r√¥le
  {nom} {type} = {valeur}
```

**KTN-VAR-004** :
```
Variable '{nom}' sans type explicite.
Sp√©cifiez toujours le type : bool, string, int, []string, map[string]int, chan error, etc.
Exemple:
  {nom} int = {valeur}
```

**KTN-VAR-005** :
```
Variable '{nom}' devrait √™tre une constante.
La valeur semble immuable (ex: Pi, Version). Utilisez const au lieu de var.
Exemple:
  const {nom} {type} = {valeur}
```

**KTN-VAR-006** :
```
Multiple variables '{noms}' d√©clar√©es sur une ligne.
D√©clarez chaque variable sur une ligne s√©par√©e pour permettre les commentaires individuels.
Exemple:
  // Var1 description
  Var1 Type1 = val1
  // Var2 description
  Var2 Type2 = val2
```

**KTN-VAR-007** :
```
Channel '{nom}' sans buffer size explicite.
Pr√©cisez dans le commentaire si le channel est buffered (avec taille) ou unbuffered.
Exemple:
  // {nom} description (buffer=100)
  {nom} chan Type = make(chan Type, 100)

  // {nom} description (unbuffered)
  {nom} chan Type = make(chan Type)
```

### Ce que le linter v√©rifie :

1. **Regroupement** : Toutes les variables doivent √™tre dans un bloc `var ()`
2. **Commentaire de groupe** : Chaque bloc `var ()` doit avoir un commentaire avant
3. **Commentaire individuel** : Chaque variable (publique OU priv√©e) doit avoir son commentaire
4. **Type explicite** : Chaque variable doit avoir son type sp√©cifi√©
5. **Const vs Var** : D√©tection de valeurs immuables qui devraient √™tre const
6. **Channel buffer** : Commentaire doit mentionner buffer size ou "unbuffered"
7. **Naming** : MixedCaps obligatoire (pas underscore, pas ALL_CAPS)

## ü§ñ Prompt IA

Pour qu'une IA comprenne et applique cette r√®gle automatiquement :

```
Tu es un expert Go. V√©rifie que TOUTES les variables package-level respectent ces r√®gles obligatoires :

R√àGLE 1 - REGROUPEMENT :
- Les variables doivent √™tre dans un bloc var ()
- Ne jamais d√©clarer : var X = 1
- Toujours d√©clarer : var ( X = 1 )

R√àGLE 2 - COMMENTAIRE DE GROUPE :
- Chaque bloc var () doit avoir un commentaire avant le bloc
- Format : // Description du groupe
- Exemple : // Configuration variables / Ces variables repr√©sentent...

R√àGLE 3 - COMMENTAIRE INDIVIDUEL :
- CHAQUE variable (publique ET priv√©e) doit avoir son propre commentaire
- Commentaire sur la ligne juste au-dessus
- Format : // NomVariable description de son r√¥le
- Exemple : // MaxRetries d√©finit le nombre maximum de tentatives

R√àGLE 4 - TYPE EXPLICITE :
- TOUJOURS sp√©cifier le type : bool, string, int, []string, map[string]int, chan error, *User, etc.
- Ne jamais √©crire : var X = 1
- Toujours √©crire : var X int = 1

R√àGLE 5 - CONST VS VAR :
- Si la valeur ne change jamais (Pi, Version), utiliser const, pas var
- var est r√©serv√© aux valeurs mutables

R√àGLE 6 - MULTIPLE ASSIGNMENT :
- Ne jamais d√©clarer : var X, Y = 1, 2
- Toujours s√©parer : var ( X int = 1; Y int = 2 )
- Permet les commentaires individuels

R√àGLE 7 - CHANNELS :
- Toujours pr√©ciser buffer size dans le commentaire
- Exemple : // Queue canal de messages (buffer=100)
- Ou : // Done signal de fin (unbuffered)

R√àGLE 8 - NAMING :
- Toujours MixedCaps : MaxRetries, maxRetries
- Jamais underscore : max_retries
- Jamais ALL_CAPS : MAX_RETRIES

D√âTECTION D'ERREURS :
1. Si une variable est d√©clar√©e seule ‚Üí ERREUR KTN-VAR-001
2. Si un bloc var () n'a pas de commentaire avant ‚Üí ERREUR KTN-VAR-002
3. Si une variable n'a pas de commentaire individuel ‚Üí ERREUR KTN-VAR-003
4. Si une variable n'a pas de type explicite ‚Üí ERREUR KTN-VAR-004
5. Si une variable a une valeur immuable ‚Üí ERREUR KTN-VAR-005 (devrait √™tre const)
6. Si plusieurs variables sur une ligne ‚Üí ERREUR KTN-VAR-006
7. Si un channel manque buffer info ‚Üí ERREUR KTN-VAR-007
8. Si nom avec underscore ‚Üí ERREUR KTN-VAR-008
9. Si nom en ALL_CAPS ‚Üí ERREUR KTN-VAR-009

EXEMPLE PARFAIT :
// HTTP configuration
// Ces variables configurent le serveur HTTP
var (
	// Port est le port d'√©coute du serveur
	Port int = 8080
	// Timeout est le d√©lai d'expiration des requ√™tes
	Timeout int = 30
	// RequestQueue canal des requ√™tes entrantes (buffer=1000)
	RequestQueue chan Request = make(chan Request, 1000)
)
```

## üìö R√©f√©rences

- [Effective Go - Variables](https://go.dev/doc/effective_go#variables)
- [Go Code Review Comments - Declaring Empty Slices](https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices)
- [Go Style Guide - Documentation](https://google.github.io/styleguide/go/decisions#documentation)
- [Google Go Style - Package-level state](https://google.github.io/styleguide/go/best-practices.html#package-level-state)

## üîÑ Sc√©narios de Test

| # | Sc√©nario | Fichier | R√©sultat attendu |
|---|----------|---------|------------------|
| 1 | Variables non group√©es | package-level.go:4-6 | ‚ùå KTN-VAR-001 |
| 2 | Pas de commentaire de groupe ET individuels | package-level.go:9-13 | ‚ùå KTN-VAR-002 + KTN-VAR-003 |
| 3 | Type non explicite | package-level.go:18-24 | ‚ùå KTN-VAR-004 |
| 4 | Commentaire groupe OK, pas individuels | package-level.go:28-32 | ‚ùå KTN-VAR-003 |
| 5 | Pas de regroupement + pas de commentaire | package-level.go:35-37 | ‚ùå KTN-VAR-001 + KTN-VAR-003 |
| 6 | Type non explicite + pas commentaire | package-level.go:41-45 | ‚ùå KTN-VAR-003 + KTN-VAR-004 |
| 7 | Pas de commentaire du tout | package-level.go:48-52 | ‚ùå KTN-VAR-002 + KTN-VAR-003 |
| 8 | Pas de regroupement + type non explicite | package-level.go:55-57 | ‚ùå KTN-VAR-001 + KTN-VAR-004 |
| 9 | Slice sans type explicite | package-level.go:61-68 | ‚ùå KTN-VAR-004 |
| 10 | Map sans type explicite | package-level.go:72-81 | ‚ùå KTN-VAR-004 |
| 11 | Naming underscore | package-level.go:85-90 | ‚ùå KTN-VAR-008 |
| 12 | Naming ALL_CAPS | package-level.go:93 | ‚ùå KTN-VAR-009 |
| 13 | Multiple variables ligne | package-level.go:97-100 | ‚ùå KTN-VAR-006 |
| 14 | Devrait √™tre const | package-level.go:104-107 | ‚ùå KTN-VAR-005 |
| 15 | Zero value non claire | package-level.go:111-117 | ‚ö†Ô∏è D√©tection complexe |
| 16 | Type manquant avec fonction init | package-level.go:121-126 | ‚ùå KTN-VAR-004 |
| 17 | Channel sans buffer info | package-level.go:130-137 | ‚ùå KTN-VAR-007 |
| 18 | Struct anonyme sans type | package-level.go:141-151 | ‚ùå KTN-VAR-004 |
| 19 | Pointer sans type explicite | package-level.go:155-160 | ‚ùå KTN-VAR-004 |
| 20 | M√©lange group√©es/non group√©es | package-level.go:164-173 | ‚ùå KTN-VAR-001 |
| 21 | Variable orpheline | package-level.go:176 | ‚ùå Toutes les erreurs |
| ‚úÖ | Code parfait | target/package-level.go | ‚úÖ Aucune erreur |

## üí° Notes

### Diff√©rences avec les constantes

| Aspect | Constantes | Variables |
|--------|-----------|-----------|
| **Mutabilit√©** | Immuables | Mutables |
| **Scope** | Compilation | Runtime |
| **Types complexes** | Non (seulement primitifs) | Oui (slice, map, chan, struct) |
| **Initialisation** | Toujours √† la d√©claration | Peut √™tre diff√©r√©e |
| **Concurrence** | Thread-safe par nature | N√©cessite synchronisation |

### Cas particuliers

**Zero value intentionnelle** :
Quand une variable est intentionnellement initialis√©e √† 0, le pr√©ciser dans le commentaire :
```go
// Counter variables
// Ces variables comptent les √©v√©nements (zero value intentionnelle)
var (
	// RequestCount compte les requ√™tes (d√©marre √† 0)
	RequestCount int = 0
)
```

**Channels** :
Toujours pr√©ciser si buffered ou unbuffered :
```go
// Communication channels
var (
	// Done signale la fin (unbuffered pour synchronisation)
	Done chan bool = make(chan bool)
	// Messages queue de messages (buffer=100 pour d√©bit)
	Messages chan string = make(chan string, 100)
)
```

**Maps et Slices** :
Initialisation explicite pr√©f√©r√©e :
```go
// Collections
var (
	// Users liste des utilisateurs actifs (initialis√©e vide)
	Users []User = []User{}
	// Cache map de cache m√©moire (initialis√©e vide)
	Cache map[string]interface{} = map[string]interface{}{}
)
```

**Variables qui devraient √™tre const** :
D√©tection de valeurs immuables :
```go
// ‚ùå MAUVAIS
var Pi float64 = 3.14159265358979323846

// ‚úÖ BON
const Pi float64 = 3.14159265358979323846
```
